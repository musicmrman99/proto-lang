#{ Original - Java, end of week 4, after:
  - weeks 1-4 - algorithmic thinking
    - week 1 (functions, variables)
    - week 2 (constants, conditionals, logical operators)
    - week 3 (iteration - for and while)
    - week 4 (arrays and indexing)

--------------------

void mouseClicked()
{
    // println("Mouse click at "+mouseX+", "+mouseY);

    // variable to store index of button that was pressed
    int whichx=-1;
    int whichy=-1;

    // for each button...
    for (int row=0; row<BUTTONSY; row++)
    {
        for (int col=0; col<BUTTONSX; col++)
        {
            // calculate x and y position of top-left of button
            int x = (col+1)*BUTTONSIZE*2;
            int y = (row+1)*BUTTONSIZE*2;

            // if the mouse pointer is "inside" this button's region
            if ((mouseX>=x && mouseX<=x+BUTTONSIZE) && (mouseY>=y && mouseY<=y+BUTTONSIZE))
            {
                // set the "which" variable to this button
                whichx=col;
                whichy=row;
            }
        }
    }

    // if we detected a click inside one of the buttons...
    if (whichx != -1)
    {
        // flip that button's state
        ButtonState[whichy][whichx]=!ButtonState[whichy][whichx];
    }
}

}#

# --------------------------------------------------

#{
defined in module "maps":
    (|) : { @1 }

    | of |
    transform each of | through |
    merge |
    if | then | otherwise |

defined in module "geometry":
    position | : symbolic type from [number --- number]
    position : { using position }
    position at | : { typed using position @1[[number --- number]] }

    radius | : number
    radius : { using radius }
    radius of | : { typed using radius @1[number] }

    circle | : symbolic type from [radius]
    circle : { using circle }
    circle with | : { typed using circle [@1[radius]] }

    | intersects | : { ... }

defined in module "events":
    act on | by | : { ... }

defined in module "raw input":
    mouse click : { ... }

    # Not included in module output:
      internal mouse position : mutable [x, y]
    mouse position : readonly view of internal mouse position
}#

references [
    "maps",
    "geometry",
    "events",
    "raw input"
]

#{ Basic Version
-------------------------------------------------- }#

# Using primitive types only and directly + associations
button at | with active status | and shape | : {[
    "active" --> @2[logical],
    "position" --> @1[[number --- number]],
    "shape" --> @3[shape]
]}

buttons : mutable [
    # Could use a literal map: [ "active" --> false, "position" --> [100, 200], "radius" --> 30 ]
    # but should use the constructor:
    mutable button at [100 --- 200] with active status false and shape circle with radius 30 #{,
    ...}#
]

flip clicked button : {
    # Note: Transform is acting on a mutable map, so it will transform in-place
    transform each in buttons through {
        if mouse position intersects "shape" of @1[button] then
            (transform "active" of @1[button] through { not @1[logical] }) otherwise @1[button]
            # OR:
            #transform "active" of @1 through using not |
    }
}

# Note: the OR above means:
# (transform "active" of @1 through using not "active" of @1 otherwise)

act on mouse input by using flip clicked button

#{ More Complex Version
-------------------------------------------------- }#

active : true
inactive : false

| button at | with shape | : {
    typed using button [
        "active" --> @1[logical],
        "position" --> @2[[number]],
        "shape" --> @3[shape]
    ]
}

buttons : mutable [
    # Could use a literal map: [ "active" --> false, "position" --> [100, 200], "radius" --> 30 ]
    # but should use the constructor:
    mutable inactive button at [100, 200] with shape circle with radius 30 #{,
    ...}#
]

flip hovered button : {
    # Note: Transform is acting on a mutable map, so it will transform in-place
    transform each in buttons through {
        if mouse position intersects "shape" of @1 then
            transform "active" of @1 through { not @1 } otherwise
            # OR:
            #transform "active" of @1 through using not @1 otherwise
            @1
    }
}

act on mouse click by using flip hovered button

#{ Advanced Version
-------------------------------------------------- }#

active status | : symbolic logical
active status : { using active status }
active : typed using active status true
inactive : typed using active status false

button | : type from [active status --- position --- radius]
button : { using button }
| button at | with shape | : {
    typed using button [ @1[active status] --- @2[position] --- @3[shape] ]
}

buttons : mutable [
    mutable inactive button at [100, 200] with shape circle with radius 30 #{,
    ...}#
]

flip hovered button : {
    # Note: Transform is acting on a mutable map, so it will transform in-place
    transform each in buttons through {
        if mouse position intersects @1[shape] then
            transform @1[active] through { not @1 } otherwise
            # OR:
            #transform @1[active] through using not @1[active] otherwise
            @1
    }
}

act on mouse click by using flip hovered button
