#{
    language: |"[]{}:@#,
    default sentence: ¬!£$%^*-+~=<>
    not special: ()-_'
        Note: `| - |` is a default sentence (subtraction), but `-` can also be used in other sentences
    not taken: `;./?&
}#

#{ Language Constructs
-------------------------------------------------- }#

#{ Basic
-------------------- }#

# Note: These all assume the existance of the Funamental Sentences (ie. built-ins)

{ # Comments
    # A line comment
    part of #{hello}# a line # An inline block comment
    #{
        A block comment
    }#
}

{ # Primitives
    5            # A numeric value (number)
    "5"          # A textual value (string)
    true / false # A logical value (logical)
    {}           # A block (block)
    []           # A map (map)

    # Primatives 'look' like a map with one element, which 'simply fits' into this language.
    # See "Data Model" for details.
}

{ # Sentences
    a variable : 5 # The sentence template `a variable` defined as the number `1` (a number)
    # A sentence can be defined as any value - number, string, logical, map, block, etc.

    a variable # A sentence (evaluates to a value - in this case, the value 5)
}

question {
    #{
        should there be a way to specify a one-to-many relationship?
        how would that be done, considering the sentence evaluation mechanism?

        see http://www.cs.columbia.edu/~sedwards/classes/2014/w4115-fall/proposals/GPL.pdf
        they proposed a syntax for adjacency, which would become something like (in my language):
    }#

    # space-delimited? not pretty
    # end-of-sentence-delimited? might lead to unresolvable ambiguous sentences
    # comma-delimited? but then you get 'is this another item in the adjacency list, or just another item' problem
    # end of set is newline-delimited? like other sentences, but might lead to lots of short lines
    ["a" -->: "b" "c"] # note the colon (gives this two meanings in different contexts !! )
}

{ # Maps - Basics
    # Note: All of these use default properties (see next section).

    [] # An empty map
    #{ Note:
        There is no distinction between the empty map (with any set of properties) and `null`
        from other languages (other languages differentiate between `[]` (empty array) and `null`).

        `null` is the type of the empty map, ie. `null []` returns true (see "Typing - Type, Typed, and Metadata Of"
        for explanation of the type system).
    }#

    # Items:
    ["a"]      # A map with one item
    ["a", "b"] # A map with two items

    # Item Removal:
    [/"a"]       # A map with one item removal
    [/"a", /"b"] # A map with two item removals

    #{
        An item removal represents 'the removal of an item'. Applying the item removal will also remove all existing associations to and from that item.
        Examples:
            If the map [/"a"] was applied to the map ["a", "b"], then the result would be ["b"]
            - ie. "a" has been removed

            If the map [/"a"] was applied to the map ["a" --- "b"], then the result would be ["b"]
            - ie. "a" and all associations to/from it have been removed
    }#

    # Associations:
    ["a" --- "b"] # A map with two items with a bi-directional association
    ["a" --> "b"] # A map with two items with a uni-directional association from "a" to "b"
    ["a" <-- "b"] # A map with two items with a uni-directional association from "b" to "a"

    # Disassociations:
    ["a" -/- "b"] # A map with two items with a bi-directional disassociation
    ["a" -/> "b"] # A map with two items with a uni-directional disassociation from "a" to "b"
    ["a" </- "b"] # A map with two items with a uni-directional disassociation from "b" to "a"

    #{
        A disassociation represents 'the removal of an association'. Disassociations do not effect items and are directional in the same way as associations.
        Examples:
            If the map ["a" -/- "b"] was applied to the map ["a" --- "b"], then the result would be ["a", "b"]
            - ie. the association is removed, but the items are not

            If the map ["a" -/> "b"] was applied to the map ["a" --- "b"], then the result would be ["a" <-- "b"]
            - ie. disassociating "a" with "b" leaves only "b" associated with "a"

            If the map ["a" --- "b"] was applied to the map ["a" --> "b"], then the result would be ["a", "b"]
            - ie. if only one direction exists in the target map, disassociating both directions will still remove it
    }#
}

{ # Sentences Templates and Blocks - Basics
    { log "hello world" } # a block
    a sentence # a sentence that executes the block it's associated with, and evaluates to whatever that results in (ie. returns)

    a sentence for a block : { log "hello world" }
    a sentence for a block # runs the block associated with the sentence template just defined
}

{ # Sentences Templates and Blocks - Placeholders and Filling Them In
    # A sentence template can include 'placeholders' that are given to the block the sentence template is defined as.
    # This will evaluate to the actual map that was passed (without extracting/copying anything).
    # Use `@`, then the placeholder number to get out the thing passed to the block.
    a sentence template | : { log @1 }

    # Incomplete sentence (error) - requires one placeholder to be filled in
    a sentence template

    # Runs the block associated with the sentence template just defined, filling in its placeholder with "hello" (a string).
    a sentence template "hello"

    # You can specify which placeholder to get from using `@n`, where `n` is the placeholder number to get the passed value for.
    add | to | : { @1 + @2 }

    # You can also apply an 'extraction map' (see below) to the placeholder using a short syntax.
    # `@1[string]` will extract all strings out of the map given for the first placeholder into another map, discarding associations.
    another template | : { log @1[string] }

    # If your sentence only has one placeholder and you use an extraction map, you can drop the placeholder number.
    another template without number | : { log @[string] }

    # The sentence template defines which placeholders you can fill in, the block defines which ones it uses.
    another add | to | : { @1 + @2 + @3 }

    # This results in 10, as the third placeholder used in the block cannot be given using
    # this sentence template (it will be implied to be the empty map).
    another add 4 to 6
}

#{ Advanced
-------------------- }#

{ # Sentence Templates and Blocks - Using
    #{
        Evaluates directly to the value of the sentence template immediately proceeding it, or to new block that passes any placeholder
        values it is given to their corresponding positions (in the same way as an ordinary sentence would be evaluated) and passes the
        placeholder values of the wrapping block for the remaining unbound placeholders of the wrapped block, in order (see examples).

        Basically, this is the partial application operator.

        Properties and Notes:

        - Early Binding: `using` differs from making a block because `using` early-binds its parameters (a block always late-binds,
          ie. evaluates the sentence when the block is run). On the other hand, only the top-level sentence after `using` is treated as
          a sentence template and handled accordingly, whereas the other sentences that are its parameters are evaluated normally and
          their *results* (whether dereferenced value, or result of a block) are bound in the clojure.

        - No Copy if No Binding: `using` does not make a clojure if there are no bindings (ie. copy the block). This is important for
          symbolic types and other symbolic/reference-based abstractions (both those in the language, and those created by developers).

        - Disambiguation: Placeholders do not need to be specified if the sentence template being used is unambiguous, but must be
          given if it is ambiguous (see examples "using - aliasing with placeholders" and "ambiguous sentences").
    }#
    using ...

    #{ Examples
    -------------------- }#

    example { # aliasing
        some block : { log "hello world" } # a sentence and block with no placeholders required / used (respectively)
        I am used : using some block # uses the block previously defined (as it binds no placeholders)
        I am used # runs the original block
    }

    example { # aliasing with placeholders
        log a thing | : { log @1 } # a sentence and block with a placeholder / that uses a placeholder (respectively)
        I am used | : using log a thing # uses the block previously defined (the final `|` (placeholder) can be inferred*; no placeholder binding)
        I am used # error, as always - incomplete sentence
        I am used "hello world" # passes the placeholder value to the block that `log a thing` is defined as

        # * only in this case - see "ambiguous sentences" example.
    }

    example { # ambiguous sentences
        # Ambiguous cases of `using` require you to add necessary placeholders in the relevant places, eg.
        hello | and another
        hello and | another
        using hello and | another # You have to include the placeholder to disambiguate
    }

    example { # partial application (ie. clojure constructor)
        more complex | | : { log [@1, @2] } # has two placeholders, uses two placeholders
        I am used | : using more complex 1 # creates a clojure that runs the block previously defined, binding the first placeholder to 1
        I am used # error, as always - incomplete sentence
        I am used 2 # logs 1 and 2 - `I am used` is a 1-placeholder partially applied version of `more complex | |` (1st placeholder is bound)
    }

    example { # partial application (arbitrary placeholder positions)
        can | bind | elsewhere | : { log [@1, @2, @3] } # has three placeholders (in different places), uses three placeholders
        I am used | : using can 4 bind elsewhere 6 # creates a clojure; the placeholder in the middle is inferred
        I am used # error, as always - incomplete sentence
        I am used 5 # logs 4, 5 and 6 - `@2` of the block `can | bind | elsewhere |` is defined as is filled in with @1 of the clojure
    }
}

{ # Sentence Templates and Blocks - With
    #{
        Creates a context that takes zero or more proceeding clauses, then for each clause, applies it to the context's current value
        and replaces the current value with what it results in.

        Basically, this is the pipeline constructor. It allows for mutable or immutable data pipelines and functor-like code (see example).
        It's also what you should use instead of the decorator pattern.
    }#
    with ...

    # Declares a contextual sentence (only contextual sentences can be used as `with` clauses).
    with | ... : ...

    #{ Examples
    -------------------- }#

    example { # with version of `apply | to |`
        apply | to | : {} # assume this exists
        with | apply | : { apply @1 to @context } # @context is a special non-positional placeholder for the context
        with ["hello"],                                    # starts with ["hello"]
            apply ["goodbye"],                             # results in ["hello", "goodbye"]
            apply ["hello" --> "goodbye"],                 # results in ["hello" --> "goodbye"]
            apply [/"goodbye", "hello" --> "see you soon"] # results in ["hello" --> "see you soon"]
    }

    example { # the various `transform`/`transform each` sentences have `with` versions
        # A simple (ish) `sum of |` definition in this language
        sum of | : {
            sum count : mutable 0
            transform each @[number] through {
                # transform sum count in-place to the sum of itself and this element
                #{
                    Note: If the given map (@1) happens to be ordered, then @[number] will make an ordered map.
                    If this happens, and since this block is returning the result of each iteration of the
                    summation, the evaluated value of the `transform each` will be a map containing the cumulative
                    sum as an ordered series. While this function discards that map, such an effect may be useful
                    for a `cumulative sum of` sentence.
                }#
                transform sum count also passing @1 through { @1 + @2 }
            }
            sum count # result in the sum count
        }

        # The actual point of this example
        sum of stuff : with "hello",      # starts with "hello"
            transform to associated value in [
                "hello" --> [1,2,3],
                "goodbye" --> [4,5,6]
            ],                             # results in [1, 2, 3]
            transform through using sum of # results in [6]
    }

    example { # with - functor-like code
        with | if non-null map to | : {
            mapper | : @1[block]
            transform @context through associated block in [
                [] --> { @1 },
                any --> { mapper @1 }
            ]
        }

        test : with "hello",
            if non-null transform through { @[number] } # not a number, so will result in []
            if non-null transform through { # Will not be run
                log @1
                @1
            }
        # `test` will be []
    }
}

example { # break, with, and using (short-circuiting the transformation chain)
    # NOTE: This is what you do instead of using the decorator pattern

    # class / constructor
    new pass once : {
        # private attribute
        switch : mutable true

        # private method
        flip switch and keep | : {
            transform switch to false
            @1
        }

        # object / public method
        {
            #{
                `immutable switch` (which copies the internal map and internal metadata) is to avoid changing the 'real' switch -
                we only want to execute different code based on its value. See "Maps - Basic Properties".
            }#
            transform immutable switch through associated block in [
                true --> using flip switch and keep @context,
                false --> { break }
            ]
        }
    }

    # the immutable version is:
    #with | pass once : new pass once

    # initialise a mutable "pass once"
    underlying pass once : mutable new pass once

    # define a context-dependent "pass once" as using whatever `underlying pass once` is, which is mutable
    with | pass once : using underlying pass once # it's still a block, so `using` it is needed

    # example 1
    with | simple fun function : { log ["you gave me an ", @1] }
    transform each ["F-", "F", "E"] through {
        with @1,
            pass once, # will stop here every time after "you gave me an F-" (`with` interprets the special constant `break`)
            simple fun function
    }

    # can 'reset' the "pass once" by mutating `underlying pass once` to a `mutable new pass once`
    transform underlying pass once to mutable new pass once

    # example 2
    say : { log @1[string] }
    transform each ["hello", "goodbye"] through {
        with @1,
            pass once # same `pass once` contextual sentence template as example 1
            say # says "hello", but not "goodbye" - how rude :P
    }
}

#{ Fundamental Sentences
-------------------------------------------------- }#

# These are implemented internally.

#{ Maps and The Data Model
-------------------- }#

{ # Overview
    #{
        The fundamental operators of maps are:
            apply
            extract
            combine
            transform
            transform each

        apply, extract, transform, and transform each
            These all take and provide maps of the same level of composition. That means you cannot
            decompose a map using these - you can only transform one map into another at the equivalent
            level of composition.

        combine
            This one reduces the level of composition by 1. It unwraps one or more maps into a single map.

        Dirivative forms of these work similarly, but have additional capabilities.
    }#
}

{ # Data Model
    #{
        All available values are internally represented as maps, and so the fundamental sentences also work on them.

        The following table lists the language's primitive types, and examples of them individually and in maps.
    }#

    external      | internal
    --------      | --------
    # null        | []
    []            | []

    # number      | [1, ...]
    1             | [1]
    multi-dim num | [1, 2]         # A "multi-dimentional number" (not an official term) is what you get if you `combine` a map of numbers
    [1]           | [[1]]
    [1, 2]        | [[1], [2]]

    # string      |  ["a", ...]
    "a"           | ["a"]
    ["a"]         | [["a"]]
    "ab"          | ["a", "b"]     # `combine`-ing a map of strings just gives you a string
    ["a", "b"]    | [["a"], ["b"]]

    # logical     | [true or false, ...]
    true          | [true]
    bit field     | [true, true]   # A "bit field" (not an official term) is what you get if you `combine` a map of logicals
    [true]        | [[true]]
    [true, false] | [[true], [false]]

    # block       | [{...}, ...]
    {}            | [{}]
    block comp    | [{}, {}]       # A "block composition" (not an official term) is what you get if you `combine` a map of blocks
    [{}]          | [[{}]]

    # map         | [...] and not number, string, logical, or block (not much point in having a type that's the same as `any`)
                                   # `combine`-ing a map of maps just gives you a map
    []            | []             # null is a special-case of a map, but should rarely, if ever, be special-cased in your code
    [[]]          | [[]]
    [[1]]         | [[[1]]]
    [[1], 2]      | [[[1]], [2]]
    [[1], "a"]    | [[[1]], ["a"]] # multiple types are allowed in a single map

    # composite   | what you get if you `combine` a map of multiple primitive types of things - only plug-ins can do anything with them
    repeat block  | [5, {}] # this is just an example - you won't (and shouldn't) use these very often

    # any         | number, string, logical, block, or map (all values have this type implicitly)
}

{ # Apply
    #{
        Takes a difference map (a map with additions and/or removals) and a map, and applies all
        additions/removals in the difference map to the map.
    }#
    apply | to | : {}
    with | apply | : {}

    #{ Examples
    -------------------- }#

    example { # map to map (the ordinary use-case)
        apply [1, 2] to []
        # Results in [1, 2]
    }

    example { # different types
        apply ["hello"] to [1, 2]
        # Results in [1, 2, "hello"]
    }

    example { # associations
        apply ["hello" --> "world"] to unique ["hello"]
        # Results in ["hello" --> "world"]
    }

    example { # removals (items and associations)
        apply [/"hello" -/- "world"] to ["again" --- "hello" --- "world"]
        # Results in ["again", "world"] - "world" doesn't have a slash before it, so isn't removed
    }

    example { # directly applying primitives and to primitives
        # Note: The meaning of the composites (ie. 'composite primitives') is undefined for all built-in sentences, but may be defined by plug-ins.

        apply [1, 2] to 3
        # Results in a composite ([3, [1], [2]] internally)

        apply 1 to [2, 3]
        # Results in a composite ([[2], [3], 1] internally)
    }
}

{ # Extract
    #{
        Takes an extraction map and a map, and extracts all item combinations in the map that match the extraction map.

        Each group in an extraction map (ie. associated items / those without a separating comma) is matched against every group
        in the given map, meaning:

        - extract [string] from ... results in all strings in the map.
        - extract [string --- string] from ... results in all cases of a string associated to a string (bidirectionally).
          - the association doesn't have to be in its own group - it will search within-group. That means that the map-extract
            sentence does combinatorial extraction. If the map being extracted from is `unique`, it will re-match up items by
            reference, as always, effectively producing the same graph with any non-matching components removed.
    }#
    extract | from | : {}

    #{ Examples
    -------------------- }#

    examples { # Basics
        example { # map from map (the ordinary use-case)
            extract [any] from [1, 2]
            # results in [1, 2] ([[1], [2]] internally)
        }

        example { # non-matching map from map (empty map)
            extract [number] from ["string"]
            # ie. internally: extract [[{...}]] from [["s", "t", "r", "i", "n", "g"]]
            # outer blocks cancel out: extract [{...}] from ["s", "t", "r", "i", "n", "g"]
            # [{}] is a block value (regardless of whether it's a block pipeline), so it is called on ["s", "t", "r", "i", "n", "g"]
            # Results in [] (empty map), as `number` does not return true if given "string"
        }

        example { # type (ie. predicate block) from map
            extract any from [1, 2]
            # Results in [1, 2] (ie. the map, as it's of the type `any`)
            # Would result in [] (null/empty map) if it contains nothing of the given type
        }

        example { # type from primitive
            extract any from 1
            # Results in 1 (1 is an 'any')
        }
    }

    examples { # Basics - Associations (groups)
        example { # Multi-match on associated values
            extract [number --- number] from [56 --- 67 --- 78]
            #{
                This is because it consideres [56 --- 67 --- 78] to be two cases of [number --- number] (ie. 56 --- 67 and 67 --- 78).
                The 67 is only duplicated in the resulting map if the given map isn't a `unique` map (see "Maps - Basic Properties"
                for details about `unique`).
            }#
        }
    }

    examples { # Primitive composites
        examples { # Matching Compositions
            example { # primitive type from primitive
                extract number from 6
                [ [META], {} ]
                [ [META], 6  ] # matches
            }

            example { # map of primitive type from primitive
                extract [number] from [6]
                [ [META], [[META], {}] ]
                [ [META], [[META], 6 ] ] # matches
            }
        }

        examples { # Folding
            example { # map of primitive type from map of primitives
                extract [number] from [6, 9]
                [ [META], [[META], {}]               ]
                [ [META], [[META], {}], [[META], {}] ] # folds map of block (it's a group in an extraction map, so folds)
                [ [META], [[META], 6 ], [[META], 9 ] ] # matches
            }

            example { # primitive type from multi-dimentional primitive (nubmer)
                extract number from combine [6, 9]
                [ [META], {}     ]
                [ [META], {}, {} ] # folds block (it's a group in an extraction map, so folds)
                [ [META], 6 , 9  ] # matches
            }

            example { # map of primitive type from map of multi-dimentional numbers
                # Note that all of this is only necessary if the maps aren't symbolically typed
                extract [number] from [combine [6, 9], combine [5, 8]]
                [ [META], [[META], {}    ]                   ]
                [ [META], [[META], {}    ], [[META], {}    ] ] # folds outer group (map of block)
                [ [META], [[META], {}, {}], [[META], {}, {}] ] # folds inner group (block)
                [ [META], [[META], 6 , 9 ], [[META], 5 , 8 ] ] # matches
            }
        }

        examples { # Wrapping - of extraction maps
            #{
                If the extraction encounters a shallower extraction map than map ...

                As the group size of the extraction map (1) is <= the group size of the map being extracted from (1), the block
                initially executes over the whole map (as it doesn't know what the block is checking for), but if it fails, then it
                checks if the map being extracted from at this level contains exactly 1 group, and if so, 'wraps the group in another
                map' (logically), and recurses to the next level of composition down.

                This case of 'recursion' is usually implemented iteratively, as the item on the extraction map side doesn't actually
                exist at this level of composition (and so doesn't have metadata) - mutating the extraction map is dangerous, copying
                it is slow, and neither are necessary for a proper implementation.
            }#

            example { # primitive type from map of primitive
                extract number from [6]
                [ [META], {}           ] # executes on the map, results in false (not a number), so ...
                [ [META], [        {}] ] # wraps
                [ [META], [[META], 6 ] ] # matches
            }

            example { # primitive type from map of multi-dimensional primitive
                extract number from [combine [6, 9]]
                [ [META], {}               ] # executes on the map, results in false (not a number), so ...
                [ [META], [        {}    ] ] # wraps group
                [ [META], [        {}, {}] ] # folds group
                [ [META], [[META], 6 , 9 ] ] # matches
            }
        }

        examples { # Wrapping - of data maps
            #{
                If the extraction encounters a deeper extraction map than map ...

                All groups in the map (except the meta block) are 'wrapped in a map' (logically), and the recursion continues on both
                sides.
            }#

            example { # map of primitive type from primitive
                extract [number] from 6
                [ [META], [[META], {}] ]
                [ [META],          6   ]
                [ [META], [        6 ] ] # wraps group (primitives only)
                                         # matches
            }

            example { # map of primitive type from multi-dimensional primitive
                extract [number] from combine [6, 9]
                [ [META], [[META], {}]               ]
                [ [META],  6          ,  9           ]
                [ [META], [        6 ], [        9 ] ] # wraps groups (primitives only)
                [ [META], [[META], {}], [[META], {}] ] # folds map of block
                                                       # matches
            }
        }

        #{
            The algorithm should make a distinction after wrapping between primitive values and map values, perhaps
            by adding a dedicated type to the wrapping map, eg. "primitive-unit". Then, the four possible options for
            'fold-after-wrap' in an extraction map are:

            - none (neither maps nor primitives)
            - primitives only
            - maps only
            - both (maps and primitives)

            The default for the primitive type maps should be:

            - null    - none (nothing to fold anyway)
            - number  - primitives only (support multi-dimensional number composites, but forbid 'a matrix of numbers is a number' problems)
            - string  - primitives only (necessary for strings, but forbids 'a matrix of strings is a string' problems)
            - logical - primitives only (support bit field logical composites, but forbid 'a matrix of logicals is a logical' problems)
            - block   - primitives only (support block pipelines, but forbid 'a matrix of blocks is a block' problems)
            - map     - maps only (a map of primitives shouldn't be considered a map - that's a composite; don't waste time trying to fold
                        over a composite's contents)

            - composite - ???
            - any       - both (usually matches any value symbolically, but in case symbolic checking is disabled, then this will make
                          procedural typing work, albeit slowly)
        }#

        example { # Strings - awkward extractions (and usefulness of symbolic typing)
            # Obviously, this would be VERY slow - O(n), where n is the length of the string ...
            extract [string] from "hello"
            [[{}]                             ]
            [ "h",   "e",   "l",   "l",   "o" ]
            [["h"], ["e"], ["l"], ["l"], ["o"]] # wrap groups (data)
            [[{}] , [{}] , [{}] , [{}] , [{}] ] # fold
                                                # match (slowly)

            # ... which is why strings are symbolically typed:
            extract string from "hello"
            string = # VVV
            [ [META: "symbolic" ---> true, ...], {}                  ]
            [ [META: "types" --> [string], ...], "h","e","l","l","o" ] # matches symbolically

            extract [string] from "hello"
            string = [[META], {...}] # ie.       V-------------V
            [ [META],                            [[META], {...}]     ]
            [ [META: "types" --> [string], ...], "h","e","l","l","o" ] # DOES NOT match symbolically !!!
            #{
                heuristics? "if first char is string, then check type"?
                but if it's a composite containing a string, then it will consider it a string (because `combine` also combines types)
            }#
        }
    }

    examples { # Custom composites
        #{
            Map of item and item only both extract right when the primitive values are of the same type as the whole,
            eg. number, string, logical, block, but not multi-type composites.
        }#

        feet | : type combine [number --- ["feet"]] # [[META], {}, ["f","e","e","t"]]
        feet : { using feet }
        | ft : { typed using feet combine [@1[number] --- ["feet"]] }
        #{
            Internally:
            Given:    [[META], [[META], 1] --- [[META], ["f","e","e","t"]]]
            Produces: [[META],          1  ---          ["f","e","e","t"] ]
        }#

        # The following sometimes excludes [META]s, and uses ["feet"] = [[META], "f","e","e","t"] to fit lines onto the screen

        examples { # Matching Compositions
            example { # custom composite type from custom composite
                extract feet from 5 ft
                [ [META], {} --- ["feet"] ]
                [ [META],  5 --- ["feet"] ] # Matches
            }

            example { # map of custom composite type from map of custom composite
                extract [feet] from [5 ft]
                [ [META], [ [META], {} --- ["feet"] ] ]
                [ [META], [ [META],  5 --- ["feet"] ] ] # Matches
            }
        }

        examples { # Folding
            example { # map of custom composite type from map of custom composites
                extract [feet] from [6 ft, 9 ft]
                [ [META], [[META], {} --- ["feet"]]                                             ]
                [ [META], [[META], {} --- ["feet"]], [[META], {} --- ["feet"]] ] # folds map of feet
                [ [META], [[META],  6 --- ["feet"]], [[META],  9 --- ["feet"]] ] # matches
            }

            example { # custom composite type from multi-dimensional custom composites
                extract feet from combine [6 ft, 9 ft]
                [ [META], {} --- ["feet"]                                    ]
                [ [META], {} --- ["feet"] , {} --- ["feet"] ] # fold group
                [ [META], 6  --- ["feet"] , 9  --- ["feet"] ] # matches
            }

            example { # map of custom composite type from map of multi-dimensional custom composites
                extract [feet] from [combine [6 ft, 9 ft], combine [5 ft, 8 ft]]
                [ [ {} --- ["feet"] ]                                                        ]
                [ [ 6  --- ["feet"], 9  --- ["feet"] ], [ 5  --- ["feet"], 8  --- ["feet"] ] ]
                [ [ {} --- ["feet"]                  ], [ {} --- ["feet"]                  ] ] # fold outer group (map of group)
                [ [ {} --- ["feet"], {} --- ["feet"] ], [ {} --- ["feet"], {} --- ["feet"] ] ] # fold inner group (feet, ie. number --- ["feet"])
                                                                                               # matches
            }
        }

        examples { # Wrapping - of extraction maps
            example { # custom composite type from map of custom composite
                extract feet from [6 ft]
                [ [META], {} --- ["feet"]            ]
                [ [META], [ [META],  6 --- ["feet"] ]] # not enough items in group to match extraction map group, so ...
                [ [META], [         {} --- ["feet"] ]] # wrap groups in maps
                                                    # matches
            }

            example { # custom composite from map of multi-dimentional custom composite
                extract feet from [combine [6 ft, 9 ft]]
                [ [META], {} --- ["feet"]                              ]
                [ [META], [ [META], 6  --- ["feet"], 9  --- ["feet"] ] ] # not enough items in any group to match extraction map group
                [ [META], [ [META], {} --- ["feet"]                  ] ] # wrap group in map
                [ [META], [ [META], {} --- ["feet"], {} --- ["feet"] ] ] # fold group
                                                                         # matches
            }

            example { # custom composite type from map of custom composites
                extract feet from [6 ft, 9 ft]
                [ [META], {} --- ["feet"] ] 
                [ [META], [ [META], 6  --- ["feet"] ], [ [META], 9  --- ["feet"] ] ] # not enough items in any group to match extraction map group
                [ [META], [         {} --- ["feet"] ]                              ] # wrap group
                [ [META], [         {} --- ["feet"] ], [         {} --- ["feet"] ] ] # fold group
                                                                                     # matches
            }
        }

        examples { # Wrapping - of data maps
            example { # map of custom composite type from custom composite (requires strategy backtracking)
                extract [feet] from 6 ft
                [ [META], [ [META], {} --- ["feet"] ] ]
                [ [META], 6 --- ["feet"]              ]
                # Enumerates the things it can do - fold extraction map, wrap data map - and uses copy-and-recurse to
                # check each of them in order without mutating either map.
                [ [META], 6                          , ["feet"]                    ] # searches within group
                [ [META], [ [META], {} --- ["feet"] ], [ [META], {} --- ["feet"] ] ] # folds the map over both 6 and ["feet"]
                [ [META], [         6               ], [         ["feet"]          ] # wraps possibly-matching items in groups
                                                                                     # (all are primitives except the string)
                                                                                     # no match

                # results in nothing, so backtracks to last enumeration point
                [ [META], [ [META], {} --- ["feet"] ] ]
                [ [META], [         6  --- ["feet"] ] ] # wrap data
                                                        # matches
            }

            example { # map of custom composite type from multi-dimensional custom composite (requires strategy backtracking)
                extract [feet] from combine [6 ft, 9 ft]
                [ [META], [ [META], {} --- ["feet"] ]      ]
                [ [META], 6  --- ["feet"], 9  --- ["feet"] ]
                # Enumerates the things it can do - fold extraction map, wrap data map - and uses copy-and-recurse to check each of them
                # in order without mutating either map.
                [6,                 ["feet"],          9,                 ["feet"]         ] # searches within groups
                [[{} --- ["feet"]], [{} --- ["feet"]], [{} --- ["feet"]], [{} --- ["feet"]]] # folds the map over 6, 9, and both ["feet"]
                [[6              ], [["feet"]       ], [9              ], [["feet"]       ]] # wraps groups in map
                                                                                             # (all are primitives except the string)
                                                                                             # no match
                [ [META], [ [META], {} --- ["feet"] ]                              ] # backtracks to last enumeration point
                [ [META], [         6  --- ["feet"] ], [         9  --- ["feet"] ] ] # wrap data groups
                [ [META], [ [META], {} --- ["feet"] ], [ [META], {} --- ["feet"] ] ] # fold group
                                                                                     # matches
            }
        }
    }
}

{ # Combine
    # Takes a map and creates a map out of all the items of all maps (non-primitives) it contains.
    combine | : {}

    #{ Examples
    -------------------- }#

    example { # maps (the ordinary use-case)
        combine [[1, 2], [3, 4]]
        # Results in [1, 2, 3, 4] - a map at one level of composition down
    }

    example { # numbers -> multi-dimentional number
        combine [1, 2, 3, 4]
        # Results in a multi-dimentional number ([1, 2, 3, 4] internally) - a map at one level of composition down
    }

    example { # strings -> string
        combine ["hello ", "world"]
        # Results in "hello world" (a string) - a map at one level of composition down
    }

    example { # logicals -> bit field
        combine [true, false]
        # Results in a bit field ([true, false], [2] ??? internally) - a map at one level of composition down
    }

    example { # blocks -> block composition
        combine [{ @1 + @2 }, { @1 - 1 }]
        # Results in a block composition ([{ @1 + @2 }, { @1 - 1 }] internally) that represents { @1 + @2 - 1 }
    }

    example { # double-combine ("combine the combination of")
        combine combine [["this ", "and "], ["that ", "is."]]
        # Results in "this and that is." - a map at two levels of composition down
    }

    example { # directly giving primitives (empty map)
        combine 1
        # Results in [] (null / the empty map) - a map at one level of composition down from a number is the empty map (as it contains no maps)
    }

    example { # directly giving composites (depends on the composite)
        test : combine [1, 2, [3]]
        # Results in [1, 2, [3]] internally

        combine test
        # Results in 3 ([3] internally)
    }
}

{ # Transform and Transform Each
    #{
        There are various forms of transform and transform each.

        `transform` generally takes a map and transforms it into another, whether mutating the original or producing a new map.
        Some sentence templates allow executing a block, providing the item to transform for the first placeholder, and result in
        the map that block results in.

        `transform each` generally takes a map and transforms it element-wise into another, whether mutating the original or
        producing a new map. Some sentence templates allow executing a block, providing each item wrapped in a map to the block,
        then unwraps (extracts) whatever map that block results in into the the new map.

        Like most fundamental sentences, `translate` and `translate each` both maintain the current level of composition. Particularly
        in the case of `transform each` (where they are used to using `for`/`foreach` loops), this may be unexpected for developers
        coming from other languages.
    }#
                                                                       # Using JS-like syntax, the format `<placeholder index>:<placeholder name>`
                                                                       # and a custom implementation of `map()` (see below):
    transform | : {}                                                   # 1:fn()
    transform | also passing | : {}                                    # 1:fn(2:otherMap)
    transform | to | : {}                                              # 2:value (will mutate 1:map if it's mutable)
    transform | through | : {}                                         # 2:fn(1:keyMap)
    transform | also passing | through | : {}                          # 3:fn(1:keyMap, 2:otherMap)
    transform | to associated value in | : {}                          # 2:keyAssocMap[1:keyMap]
    transform | through associated block in | : {}                     # 2:keyAssocMap[1:keyMap](1:keyMap)
    transform | also passing | through associated block in | : {}      # 3:keyAssocMap[1:keyMap](1:keyMap, 2:otherMap)

    transform each | : {}                                              # map(1:fns, (fn) => fn())
    transform each | to | : {}                                         # map(1:fns, (fn) => 2:value) (will mutate 1:map if it's mutable)
    transform each | also passing | : {}                               # map(1:fns, (fn) => fn(2:otherMap))
    transform each | through | : {}                                    # map(1:keyMap, (item) => 2:fn([item]))
    transform each | also passing | through | : {}                     # map(1:keyMap, (item) => 3:fn([item], 2:otherMap))
    transform each | to associated value in | : {}                     # map(1:keyMap, (item) => 2:keyAssocMap[item])
    transform each | through associated block in | : {}                # map(1:keyMap, (item) => 2:keyAssocMap[item]([item]))
    transform each | also passing | through associated block in | : {} # map(1:keyMap, (item) => 3:keyAssocMap[item]([item], 2:otherMap))

    #{ where map() in the example 'equivalent' code is defined differently:
        The map/graph equivalent of (Python):

            function map(list, fn) {
                newList = [];
                for (item of list) {
                    newList.push(...fn(item)); // Ie. add everything (0 or more items) in the returned map - and it **will** be a map
                }
                return newList;
            }

        Or, if this language had a 'for' construct like Python's (which it doesn't and never will),
        and could use `transform` in a definition of `transform` (which is a recursive definition,
        so cannot) it would look something like:

            map | | : {
                givenMap : @1[any]   # `givenMap` is the value for placeholder 1 (with all associations removed)
                newMap : []          # newMap = [];
                for item in list:    # as it says:
                                    #   newItems = fn(item); // `fn` is the value for placeholder 2, pretty much
                    newItems : transform item through @2[block]
                                    #   map.apply(newItems)
                    to newMap, apply newItems
                newMap               # return newMap
            }
    }#

    # The `with` versions of `transform` and `transform each`
    with | transform : { transform @context }
    # ...

    #{ Examples
    -------------------- }#

    example {
        transform [1, 2] through { @[number] }
        #{
            Passes [1, 2] (ie. [[1], [2]] internally) to the block.
            The block extracts all numbers (eg. 1 externally, or [1] internally), returning [1, 2] (ie. [[1], [2]] internally).
            Transform results in that map.
        }#
    }

    example {
        transform each [1, 2] through { @[number] }
        #{
            Transforms [1, 2] (ie. [[1], [2]] internally) to [[1], [2]] (ie. [[[1]], [[2]]] internally), then passes each wrapped map to the block.
            The block receives eg. [1] ([[1]] internally), and extracts all numbers (still resulting in [1] / [[1]]), and results in that map.
            Transform each then does `apply <that value> to <new map>`, eg. `apply [1] to []`, which adds all items you return to the result.
            After doing that for each item, transform each finally results in the new map.
        }#
    }
}

idea { # Dates (constructing and using composites)
    # days in month
    days in month | : using number
    days in month : { using days in month }
    new days in month | : { typed using days in month @1 }

    days in months : [
        1 --> new days in month 31,
        2 --> new days in month 28,
        3 --> new days in month 31,
        4 --> new days in month 30,
        5 --> new days in month 31,
        6 --> new days in month 30,
        7 --> new days in month 31,
        8 --> new days in month 31,
        9 --> new days in month 30,
        10 --> new days in month 31,
        11 --> new days in month 30,
        12 --> new days in month 31
    ]

    day of month | | : type from {
        days in this month : with days in months,
            extract [@1[number] --> days in month],
            extract [days in month]

        @2[number] >= 1 and @2[number] <= 28
    } and using number
    day of month | : { using day of month @1 }

    month | : type from { @1[number] >= 1 and @1[number] <= 12 } and using number
    month : { using month }

    year | : using number
    year : { using year }

    date | : type from [day, month, year]
    date : { using date }

    |/|/| : {
        typed using date [
            typed using day @1[number],
            typed using month @2[number],
            typed using year @3[number]
        ]
    }

    13/5/2023 # a valid date - it's not a double-division because longest-sentence-wins
    # How to make a double-division:
    result : with 13, /5, /20 # would work
    13/5/20 # hmm ...
}

#{ Basic Operators
-------------------- }#

{ # Arithmetic Operators (work on primitive and normal numbers and blocks, and maps containing either (mixed))
    # Unary
    + : {} # unary no-op
    - : {} # unary negation

    # Binary
    | + | : {} # addition
    | - | : {} # subtraction
    | * | : {} # multiplication
    | / | : {} # division
    | ^ | : {} # exponentiation
    | mod | : {} # modulo

    # Alises
    | ÷ | : {} # division
    | × | : {} # multiplication
    | x | : {} # multiplication
    | X | : {} # multiplication

    positive : {} # unary no-op
    negative : {} # unary negation

    | plus | : {}            # addition
    | minus | : {}           # subtraction
    | multiplied by | : {}   # multiplication
    | divided by | : {}      # division
    | to the power of | : {} # exponentiation
    | modulo | : {}          # modulo
}

{ # Logical Operators (work on primitive and normal logicals and blocks, and maps containing either (mixed))
    not | : {} # logical NOT, plus the block equivalent
    | and | : {} # logical AND, plus the block equivalent
    | or | : {}  # logical OR, plus the block equivalent
}

{ # Comparative Operators (work on primitive and normal 1D numbers, strings, and blocks, and maps containing either (mixed))
    | = | : {}  # is equal to (check)
    | != | : {} # equivalent to `not | = |` (check)
    | > | : {}  # is more than (check)
    | < | : {}  # is less than (check)
    | >= | : {} # is more than or equal to (check)
    | <= | : {} # is less than or equal to (check)
    | ~= | : {} # is approximately equal to (check)

    # `~=` / `≈` are usually used in combination with `| +- |` to indicate the range of equality,
    # eg. `5 ~= 6 +- 1.5`. See the `range` type below.

    # Alises
    | ≠ | : {} # equivalent to !=
    | ≈ | : {} # equivalent to ~=
    | ≥ | : {} # equivalent to >=
    | ≤ | : {} # equivalent to <=

    | is equal to | : {}     # equality check
    | is not equal to | : {} # inverse equality check
    # ...
}

#{
    ====================================================================================================
    CHECK EVERYTHING AFTER THIS POINT FOR DATA MODEL COMPLIANCE
    ====================================================================================================
}#

#{ Typing (Advanced)
-------------------- }#

#{
    This language supports three kinds of typing - symbolic, structural, and procedural - in different ways.
    See the "Data Model" section for the built-in type definitions.
}#

# The different inter-related components:
extract
extract symbolic [] from []
@n
@n[symbolic map-thing]
extract symbolic [] from @n
type
type from
typed

# ------------------

#{
    All primitives (including 'real' maps) are logically wrapped in an internal map that contains the metadata
    and the contents. `symbolic` is another modifier that makes `extract` and `@n[]` only consider data to be
    of that type if its internal map contains that type (by reference). Ie. it prevents procedural/structural
    typing.

    ???
}#

example { # actor example
    #{
        In other languages, you often have to make domain types that constrain both the data they can holdand the
        operations you can perform on them. This is usually done with classes, especially those with getters and
        setters. Extraction operators often already exist, so this is unnecessary. If you want to hide information,
        often all you have to do is provide a public type that contains less than the whole private type.

        Eg. for a game:
    }#

    position : symbolic number
    angle : symbolic type from { @1[number] in range } # `symbolic` copies the internal map and metadata map of `number`, then adds `symbolic`

    # An enumeration
    standing : symbolic type from {}
    walking : symbolic type from {}
    running : symbolic type from {}
    animation state : type from [
        using standing,
        using walking,
        using running
    ]

    persistable | : type from ["id" --> number]
    persistable : { using persistable }

    # An actor
    actor | : type from [
        "name" --> string,
        "position" --> position
        "rotation" --> angle,
        "animation state" --> animation state
    ]
    actor : { using actor }

    # An item
    item | : type from 
}

{ # Procedural Typing - Basics
    #{
        Procedural typing involves using blocks that result in true or false based on whether the item you give them is
        'of that type', or not. Creating a procedural type involves defining two sentence templates:

        - The type itself: A sentence template with one placeholder as a block that returns true if its first placeholder
            value is 'of that type', and false if it is 'not of that type'.

        - The type checker: A sentence template with no placeholders as a block that results in the type itself (the block).

        All of the built-in types support procedural typing.

        You can then use a sentence with the second template to extract values from another map, like so:
    }#

    # Using built-in types:
    test map : ["hello", "world", 5]
    extract [string] from test map # Results in ["hello", "world"]

    # Using custom types:
    # The type itself (returns true if its first placeholder value is a number more than 10)
    number more than ten | : { @1[number] > 10 }
    # The type checker
    number more than ten : { using number more than ten }

    # Usage example
    a list of numbers : [1, 5, 14, 83, 2]
    extract [number more than ten] from a list of numbers # Results in [14, 83]

    # You can also request a number more than 10 directly, rather than a map of them, by not wrapping
    # it in another map in the extraction sentence:
    a number : 6
    extract number more than ten from a number # Results in 6 - it is a number
    #       ^                  ^ - note the missing [ and ]
}

{ # Procedural Typing - Type and Type From
    #{
        The `type from` built-in sentence can sometimes help you make procedural types. `type` is the type of types (see
        bottom of this section).

        `type from |` creates a type block (ie. a block that returns true or false based on its placeholder's value) from what you
        give it.

        Specifically, if you give it:
        - a map, it will first make a block that extracts the 1st placeholder of `type from` from the 1st placeholder of that block.
        - a block, then that block will be used directly.

        Finally, it wraps the resulting block (either the given one or the made one) in another block that recursively checks
        that every member of the result of the given/made block is a non-empty map.

        Basically, a block you give to `type from` should result in a map - if it contains empty maps anywhere in the tree, then the
        type will result in false; if not, it will result in true.

        The forms of `type`/`type from` are:
    }#
    type | : {}
    type : { using type }
    type from | : {}

    # Examples:

    example { # map version
        example : type from ["hello" --> string]
        extract example from ["hello" --> "world"] # Results in ["hello" --> "world"] - ie. matches
    }

    example { # block version
        # Using this type ...
        number more than ten | : { @1[number] > 10 }          # The type itself
        number more than ten : { using number more than ten } # The type checker

        # ... we can define this type:
        pairs of numbers more than ten | : type from { @[number more than ten --- number more than ten] }
        pairs of numbers more than ten : { using pairs of numbers more than ten }

        # Then use extract to check types:
        extract pairs of numbers more than ten from [
            1 --- 1   # neither > 10
            1 --- 10  # neither > 10
            1 --- 11  #     one > 10
            11 --- 11 #    both > 10 - included
            53 --- 13 #    both > 10 - included
            53 --- 2  #     one > 10
        ]
        #{
            If the block you gave `type from` earlier results in the empty map when given this map, then this map is
            not considered to be of the type `pairs of numbers more than ten`. If it doesn't, it is considered to be
            of that type.

            In this case, it *is* of that type, as there are two items in the map that meet the extraction criteria.
        }#
    }

    #{
        Note that `type` should be the type of all types. (It's even the type of itself!) This means that procedural types
        that do not use `type from` (which automatically gives the resulting block the `type` type) should at least use
        `typed using type` instead. Typing your types properly like this only matters when using symbolic types (you'll
        see why in "Symbolic Typing" below), so it doesn't matter when introducing types to beginners, but should be done
        for 'real' code.

        For example, the `number more than ten` type we made in "Procedural Typing - Basics" should really be defined as:
    }#
    number more than ten | : typed using type { @1[number] > 10 }
    #                        |______________| - should include this to say "this block is a type, not just some random block"
}

{ # Procedural Typing - Typed
    #{
        The `typed` sentence is a map modifier (like unordered, unique, mutable, etc.) that does two things:

        - Checks that the given map (2nd placeholder) is of the given type (the type block given for the 1st
          placeholder's value). What the language does if it's not of that type depends on the current settings
          of the interpreter - it will either:
          - crash the program with a fatal error
          - not add the type to the map's metadata, with or without warning you that it hasn't (depends on
            settings).
          - remove everything that doesn't conform to the type from the map, leaving everything that the type
            does not know about, with or without warning you that it has (depends on settings)

        - Adds the given type (by reference) to the metadata of the given map.

        After this point, operations on the map (whether mutable or immutable) will check that the type is still
        valid for the new map. If it's not, what the languages does again depends on the current settings of the
        interpreter - it will either:

        - crash the program with a fatal error
        - remove the type(s) that the map is no longer a type of from the map's metadata, with or without
          warning you that it has (depends on settings)
        - remove everything that no longer conforms to the type from the map, leaving everything that the type
          does not know about, with or without warning you that it has (depends on settings)

        `typed | |` is often used as `typed using | |` (ie. `typed (using |) |`) to avoid evaluating the type
        block as a sentence. If you have parameterised types, then sometimes you do want it to be evaluated to an
        actual type.

        The `typed` sentence template is:
    }#
    typed | | : {}

    example { # typed
        example type | : type from ["hello" --> string]

        typed using example type ["hello" --> 6]       # not valid - what it does depends on interpreter settings
        typed using example type ["hello" --> "world"] # valid
        typed using example type [                     # valid
            "hello" --> "world",
            "goodbye" --> "world"
        ]
    }
}

{ # Structural Typing
    #{
        Structural typing is useful when you want to define a type that has multiple items. Creating a structural type
        simply requires defining a sentence template as an extraction map.

        Note that 'structural types' are not actually types, as they are not blocks that return true or false. This
        means they can't be used to type another map (using `typed`), but they can be used in extraction maps.

        You can then use a sentence with that definition to extract values from another map that match it, like so:
    }#
    example {
        # The structural type
        # Note: This 'type' is really just an extraction map definition.
        map of numbers or strings : [number, string]

        # Example 1:
        a list of things : [[5, "hello"], [6, "world"], "not this one", [8, "yes", "!"]]
        extract [map of numbers or strings] from a list of things # Results in [[5, "hello"], [6, "world"], [8, "yes", "!"]]
        # Note that last item - it contains two strings, but is still included in the type.

        # Example 2: You can also require a "map of numbers or strings" directly, rather than a map of them, by not wrapping
        # it in another map in the extraction sentence:
        a thing : [5, "yes"]
        extract map of numbers or strings from a thing # Results in [5, "yes"]
        #       ^                        ^ - note the missing [ and ]
    }

    #{
        One of the useful things about structural types is that, given a single map, it may be of multiple structural
        types without explicitly saying it is when you define it, like so:
    }#
    example {
        example type a : [number --- string] # map of a number associated with a string
        example type b : [number --- string --- number] # a map of a number associated with a string, which is itself associated with another number

        # `example thing` is of *both* structural types we've just defined - without us saying it's of either type here:
        example thing : [
            3 --- "string" --- 7,
            6 --- "doubled" --- 14
        ]
        extract example type a from example thing # results in [3 --- "string", 6 --- "doubled"]
        extract example type b from example thing # results in [3 --- "string" --- 7, 6 --- "doubled" --- 14]
    }

    #{
        Handling the 0-item (null, empty list), 1-item (single item, list of one item), and >1-items (list of items)
        cases is one of the fiddly things to do in other languages. This language:
        
        - Largely lets you ignore the 0-item case (null and the empty list are the same thing in this language), as
          they will be warned about (if enabled), and passed on without special-casing.

        - Largely lets you handle the 1-item and >1-items cases in the same way without special-casing, as all of the
          built-in sentences are multiple-item-aware.

        Typing the different cases is also not too difficult:
    }#
    example {
        # Uses structural typing 
        map of numbers or strings : type from [number, string]
        
        map of at least one number and one string : typed using type type from [number] and type from [string]
        some map : typed using map of at least one number and one string [1, "hello", "world", 66, 3, 78456]
    }
},

{ # Symbolic Typing
    #{
        Symbolic typing (also known as "Nominal Typing" outside of this language) is useful WHY???

        Creating symbolic types is like creating procedural types. To use symbolic typing, you must use the `typed`
        built-in sentence.
    }#

    # Examples:

    example { # typed - modifiers and 'constructors'
        # A type
        example type : type from unordered ["hello" --> string] # would `type from unordered ["hello" --> string]` work ???

        # A constructor (a block that creates maps of that type)
        example | : {
            unordered typed using example type [
                "hello" --> @1[string]
            ]
        }
    }

    example { # parameterised types
        # Parameterised type
        items of | : {
            T | : @1[type] # Remember: `type` is a type, like `map`, `number`, etc.
            T : { using T }

            type from [ "item" --> T ]
        }

        # A test map
        some items : [
            ["item" --> 5],
            ["item" --> 6],
            ["item" --> 7],
            ["item" --> 8]
        ]

        # Instantiating that type (`items of number`) to extract from a map (`some items`)
        extract items of number from some items # Results in all of the items in `some items`
    }
}

{ # Metadata
    #{
        To extract type information (including other kinds of type information, like modifiers), you can use the
        `metadata of` built-in sentence.
        
        `metadata of` returns the metadata of a map. This contains all type information and some language implementation
        details, including the results of modifiers like ordered, unique, mutable, restricted, typed, etc., and a
        collection of the enclosed maps for block-type maps.

        The metadata of a map is read-only outside of the language implementation.

        The `metadata of` sentence template is:
    }#
    metadata of | : {}

    # Examples:

    example { # metadata of
        some type : type from { @1[number] }
        test : mutable unique typed using some type [1, 2, 3]
        metadata of test
    }
}

#{ Other (Advanced)
-------------------- }#

{ # Modules and References
    # `module` is just like any other type
    module | : type from {} # checks for 'module' and 'block' types and some other stuff (internal)
    module : { using module }
    module of | : { typed using module @1[block] }
    module from | : { transform @1[block] } # block to make a module out of a string given by the given block (ie. a limited form of eval())

    # Common sentences to use with `module from |` are found in the built-in I/O modules, eg. constructors for files, sockets, network locations, etc.

    #{
        gets `@[module and block]`, evaluates those blocks (they must require no placeholders) without destroying their namespace objects
        once they return, then back-links the returned namespaces to the current namespace (top of the stack) in the scope (map/graph).

        A scope is a back-linked tree (stored in a map/graph) from the namespace of the current stack frame to the namespaces
        of each stack frame down the stack, plus any dynamic namespaces that were added with `references`. Eg. given a call stack:

          {} of `my sentence |`
          {} of `other sentence |`
          {} of `root sentence |`

        Then the scope in the top stack frame might look like:

          [
            namespace of {} of `my sentence |`
            <-- namespace of {} of `other sentence |`
            <-- namespace of {} of `root sentence |`
          ]

        Doing `references some module`
    }#
    references | : {}

    #{ Examples
    -------------------- }#

    example { # module of - basic
        # Defines a module
        my example : module of {
            this | sentence | can be used : { log [@1, @2] }
        }

        # Runs the module and back-links its final namespace from the current block's namespace in the scope graph
        # Note: You must use `using` for sentence templates that are bound to modules directly, as `references`
        #       must receive the block, not the result of the block.
        references using my example

        # Can now use this sentence outside of the module - the module's final namespace is now in this block's scope
        this | sentence | can be used
    }

    example { # module of - parameterised
        # a parameterised module definition - fill in its placeholder, and it will result in a module
        parameterised mod | : {
            param : @1 # block or non-block - doesn't matter
            module of {
                this : ["hello" --> param]
            }
        }

        # A references statement
        references parameterised mod "world" # blocks that return modules don't need `using`
    }

    example { # module from - external resources
        module from content of file at "hello.ptl"
    }

    wishlist { # parameterised modules (rather than perameterised blocks that return modules) - requires a namespace-transparent `using`
        parameterised mod | : module of {
            this : ["hello" --> param]
        }

        references [
            # It would be nice if `using` produced a clojure block with a 'transparent' namespace if you
            # `using` a sentence template that resolves to a block. This would allow you to `using`
            # parameterised modules in the same way as non-perameterised ones.
            using parameterised mod "world"
        ]
    }
}

{ # Maps - Basic Properties
    # The 'default properties' (also mentioned in the previous section) are marked as '(Default)'.
    # The implementation of the language handles the most efficient and appropriate underlying representations for the map.

    # These can be modified with the following keywords that appear and behave like sentences that take a map and sometimes a block:
    ordered | : {}      # (Default) Map is kept in the order added to the map (ie. order of apply()s foremost, then in order given in code)
    ordered | | : {}    #           Map is kept in the order defined by the given comparator block (1st placeholder - See [1])
    unordered | : {}    #           Map is not ordered (items are not guaranteed to be extracted in the order they were added - useful for performance)

    non-unique | : {}   # (Default) Members of map are not kept unique (can contain the same item twice)
    unique | : {}       #           Members of map are kept unique by item reference (referring to an existing item refers to the one already in the map)
    unique | | : {}     #           Members of map are kept unique by given identity block (1st placeholder - See [2])

    # About operations, not data structures ...

    immutable | : {}    # (Default) Members cannot be added to or removed from map directly (map can be copied and changes made to the new map, in which case the new map will also be immutable by default)
    mutable | : {}      #           Members can be added and removed from map directly

    #{
        [1] Ie. a block (or `using` sentence) that takes two items and results in:
            - a negative number if `@1 < @2`
            - 0 if `@1 = @2`
            - a positive number if `@1 > @ 2`

        [2] Ie. a block (or `using` sentence) that takes the map to maintain uniqueness of its members and an item,
            and returns a map containing all items in the given map that are considered 'identical' to the given item.
    }#

    #{ Examples
    -------------------- }#

    # Only non-default properties are demonstrated.

    example { # unordered
        unordered []
    }

    example { # ordered using
        numeric order | | : { @1[number] - @2[number] }
        ordered using numeric order []
    }

    example { # unique
        my map : unique [1, 1, 2, 3, 5] # results in the map [1, 2, 3, 5] - both 1s refer to the same item (primitives are memoised by default)
        new map : with my map, apply [3]  # will copy the map (`mutable` wasn't specified), but `new map` will still be [1, 2, 3, 5], as 3 is already in it
    }

    example { # unique using ...
        numeric value | : { @[number] }
        unique using numeric value [1, 1, 2, 3, 5, "hello"] # results in the map [1, 2, 3, 5], as 1 is in twice, and "hello" is not a number
        #{
            Note: `numeric value` will return [] (empty map) if given a non-number, ie. 'not identifiable'/'not valid member'.
                  This can be used as a type filter, but shouldn't be - it still has unique semantics. If you need a type restriction,
                  use the type restriction mechanisms (eg. `new map of <schema ...> containing <content ...>`).
        }#
    }

    example { # more complex unique using ... + `<properties ...> map [containing ...]`
        #{
            Note: `ordered` (and the other map properties) also apply to types, as they are maps, and the `map` type is clever
            enough to check its own properties and only return `true` for a given item when it is a map with those properties.
        }#
        entity id | : { associations of "id" in combine @[ordered map containing ["id" --> number]] }

        # Can use it directly - produces 14562, ie. [14562]
        entity id ["id" --> 14562, "other" --> 2, "fields" --> [2241, 5672, 4234, 5267, 6234]]

        #{
            Produces a map of 3 elements, as the ID 14564 is duplicated (it appears twice), regardless of
            the fact that they are different objects. As these are ordered, the first one seen will always be kept
            (`unordered unique using |` maps do not have this guarantee).
        }#
        unique using entity id | [
            ["id" --> 14562, "other" --> 2, "fields" --> [2241, 5672, 4234, 5267, 6234]],
            ["id" --> 14563, "other" --> 2, "fields" --> [2241, 5256, 4234, 6234]],
            ["id" --> 14564, "other" --> 2, "fields" --> [2241, 8346, 2342, 9371]],
            ["id" --> 14564, "other" --> 2, "fields" --> [2241, 8346, 2342]]
        ]
    }

    example { # mutable
        mutable []
    }

    example { # multiple properties
        unordered unique mutable [] # An unordered, unique, mutable map
    }
}

{ # Maps - Restriction Properties
    restriction value : type from {} # the type of restriction values (implemented internally)

    # Constructors for restriction values
    nowhere : {}
    front : {}
    back : {}
    top : {}
    bottom : {}
    front and back : {}
    top and bottom : {}
    anywhere : {}

    restriction operation : type from {} # the type of restriction operations (implemented internally)

    # Constructors for restriction operations
    reading : {}
    writing : {}
    adding : {}
    removing : {}

    # first placeholder can be: nowhere, top|front, bottom|back, both, anywhere
    # second placeholder can be: reading, writing, adding, removing (ie. CRUD)
    | for | : { transform @1[block] also passing [@2, @3] } # `@2` will be the operation (add/remove/etc.), `@3` will be the map itself

    ordered restricted [using back for adding, using front for removing, using none for writing] [] # << eg.

    # How the other modifiers affect it (eg. queue)

    unordered queue [] # placeholder extraction / `get` and `apply` would take from / add to an unknown (but probably not random) position
    unique queue []    # cannot `apply` items to the back that already exist in the queue
    mutable queue []   # `apply` mutates the original queue (probably what you want)

    #{ Built-in sets
    -------------------- }#

    # Note: Most of these do not restrict read so that the map can be copied.

    no-read | : { restricted using nowhere for reading @1 } # note that you will end up with the empty map if you try to copy a no-read map
    no-write | : { restricted using nowhere for writing @1 }
    no-add | : { restricted using nowhere for adding @1 }
    no-remove | : { restricted using nowhere for removing @1 }

    read-only | : { # useful for modules
        restricted [
            using nowhere for adding,
            using nowhere for removing,
            using nowhere for writing
        ] @1
    }
    stack | : {
        restricted [
            using top for adding,
            using top for removing,
            using top for writing
        ] @1
    }
    queue | : {
        restricted [
            using back for adding,
            using front for removing,
            using nowhere for writing # cannot add and remove from any one place
        ] @1
    }
    deque | : {
        restricted [
            using front and back for adding,
            using front and back for removing,
            using front and back for writing
        ] @1
    }
}

#{ Utilities
-------------------- }#

# THIS DOES COMPLY WITH THE DATA MODEL
{ # Associate and Disassociate
    # A one-to-many to many-to-many converter - very useful for >2 items connected to the same thing
    # Because ... One item: [a --> b]; two items: [a --> b <-- c]; three items: not possible without variables.
    associate each of | with | by | : {
        transform each @1[any] also passing @2[any] through @3[block]
    }
    associate each of | with | : { associate all of @1 with @2 by { [combine @1 --- @2] } }
    associate each of | to | : { associate all of @1 with @2 by { [combine @1 --> @2] } }
    associate each of | from | : { associate all of @1 with @2 by { [combine @1 <-- @2] } }
    disassociate each of | with | : { associate all of @1 with @2 by { [combine @1 -/- @2] } }
    disassociate each of | to | : { associate all of @1 with @2 by { [combine @1 -/> @2] } }
    disassociate each of | from | : { associate all of @1 with @2 by { [combine @1 </- @2] } }

    #{ Examples
    -------------------- }#

    example {
        # unique map combines associations by identity (and all strings are memoised, so all "hello"s here refer to the same item
        combine unique [
            associate each of ["yay", "the", "other"] from "hello"
            associate each of ["hello", "world"] to "hello"
        ]
        #{
            results in (not valid syntax - just to give the idea):
            [
                    "yay" <--\   /--> "the"
                             |   |
                "world" --> "hello" --> "other"
                              | ^
                              |_|
            ]
        }#
    }
}

#{ Built-In Non-Primitive Types
-------------------------------------------------- }#

{ # range (and all of its aliases)
    #{ In other languages
        Other languages would need to do this to get similar behaviour (eg. Java-ish):
            // You might have to implement ImmutableHashMap too
            class Range extends ImmutableHashMap {
                public final float start;
                public final float end;
                public final boolean incStart;
                public final boolean incEnd;
                public final float step;

                Range(
                        float start,
                        float end,
                        float step,
                        boolean incStart,
                        boolean incEnd
                ) {
                    super();

                    // Some languages don't require these to be listed twice, eg. C++'s initialisation
                    this.start = start;
                    this.end = end;
                    this.step = step;
                    this.incStart = incStart;
                    this.incEnd = incEnd;
                }

                // some other stuff

                // Note: This doesn't work for multiple ranges - you'd have to loop outside
                public inRange(float number) {
                    boolean aboveStart = false;
                    if (this.incStart) {
                        aboveStart = number >= this.start;
                    } else {
                        aboveStart = number > this.start;
                    }

                    boolean belowEnd = false;
                    if (this.belowEnd) {
                        belowEnd = number <= this.end;
                    } else {
                        belowEnd = number < this.end;
                    }

                    return aboveStart && belowEnd;
                }

                // You must implement the iteration interface to be usable in a `for`/`foreach` loop, even in Python/JS/PHP.
                public iter() {} // creates an iterator object, possibly another class, or ...
                public next() {} // gets the next item / moves the cursor to the next item for 'this' object (both mutable), or ...
                // you could use an eg. generator function in Python / JS - you'd still have to implement it, though
            }

            // You may not need a main() at all (eg. Python, JS, PHP, etc.)
            main() {
                // Looping
                for (num : new Range(5, 6, 0.1, true, false)) { // "What do these parameters mean again?"
                    do something with num;
                }

                // 
            }

        And that's not mentioning all of the things you can do *after* the thing is created.
    }#

    # A basic range, eg. [5 --> 6]
    range | : type from [number --> number]
    range : { using range }

    # A more advanced range (with 'edging', ie. whether the range is inclusive or not)
    ordering | : symbolic type from [block]
    ordering : { using ordering }
    inclusive : typed using ordering { @1 <= @2 }
    exclusive : typed using ordering { @1 < @2 }

    # The range must contain a step value for this type to apply
    stepped | : type from ["step" --> number]
    stepped : { using stepped }

    # At least some numbers must be 'edged' for this type to apply
    edged | : type from [number --- ordering]
    edged : { using edged }

    # Constructor for a stepped and edged range, with all types symbolically applied
    range from | (|) to | (|) step | : {
        unordered
        typed using range
        typed using stepped range
        typed using edged range
        [
            @2[ordering] --- @1[number] --> @3[number] --- @4[ordering],
            "step" --> @5,
        ]
    }

    # Constructors - Operator-based ranges centred on a given value
    | +- | (|) step | : { range from @1[number] - @2[number] (@3[ordering]) to @1[number] + @2[number] (@3[ordering]) step @4[number] }
    | +- | step | : using | +- | (inclusive) step |
    | +- | (|) :    using | +- | (|) step 2 * abs of @1[number] - @2[number]
    | +- | :        using | +- | (inclusive)

    { # Constructor aliases
        # Same as +- above
        | ± | (|) step | : using | +- | (|) step |
        | ± | step | :     using | +- | step |
        | ± | (|) :        using | +- | (|)
        | ± | :            using | +- |

        # Other versions
        | (|) to | (|) step | : using range from | (|) to | (|) step |
        | (|) to | step | :     using range from | (|) to | step |
        | to | (|) step | :     using range from | to | (|) step |
        | to | step | :         using range from | to | step |
        | (|) to | (|) :        using range from | (|) to | (|)
        | (|) to | :            using range from | (|) to |
        | to | (|) :            using range from | to | (|)
        | to | :                using range from | to |

        between | (|) and | (|) step | : using | (|) to | (|) step |
        between | (|) and | step | :     using | (|) to | step |
        between | and | (|) step | :     using | to | (|) step |
        between | and | step | :         using | to | step |
        between | (|) and | (|) :        using | (|) to | (|)
        between | (|) and | :            using | (|) to |
        between | and | (|) :            using | to | (|)
        between | and | :                using | to |
    }

    start of | : {
        with @1,
            extract range,
            extract [number <-- number --- ordering],
            extract [number --- ordering]
    }
    end of | : {
        with @1,
            extract range,
            extract [number --> number --- ordering],
            extract [number --- ordering]
    }

    # In-range check
    # `something is between | (|) and | (|) step |`
    | is | : {
        # first extraction is a 'where' clause, second extraction is a 'select'
        range start : extract [number --- ordering] from @2[number <-- number --- ordering]
        range end : extract [number --- ordering] from @2[number --> number --- ordering]

        | is after | : { transform @2[number] also passing @1[number] through @2[ordering] }
        | is before | : { transform @1[number] also passing @2[number] through @2[ordering] }

        @1[number] is after range start and @1[number] is before range end
    }

    transform each values in range from 6 (exclusive) to 9 (exclusive) step 0.1 through {}

    sequence | from | until | : {
        counter : mutable @2[any]
        update | : @1[block]
        using update counter
    }

    # Sequence generator
    values in | : {
        step : transform "step" to associated value in @1
        
        range end : extract [number --- ordering] from @2[number --> number --- ordering]
        start : transform

        sequence using + step from 
    }

    #{ Examples
    -------------------- }#

    example { # simple example
        between 1 and 9 step 0.5 # ie. range(1, 10, 0.5) in Python
    }
}

#{ Familiar language features
-------------------------------------------------- }#

# Note: These are all expressions, not statements.

{ # 'if' statement/expression
    if | then | otherwise | : {
        transform @1[logical] to associated value in [
            true --> @2[any],
            false --> @3[any]
        ]
    }
    if | then | : { if @1[logical] then @2[block] otherwise {[]} }

    # If you want to call that `else`, not `otherwise`, then you can:
    if | then | else | : { if @1[logical] then @2[any] otherwise @3[any] }

    #{ Examples
    -------------------- }#

    example {
        some condition : 5 > 5 # false
        if some condition then 3 otherwise 5
    }
}

{ # 'switch' statement/expression (or something like it)
    if | is | : {
        combine [
            transform @1[any] through associated block in @2[any --> block]
            transform @1[any] to associated value in @2[any --> not block]
        ]
    }

    #{ Examples
    -------------------- }#

    example {
        some var : "something else"
        default value : "whatever"
        if some var is [
            "something" --> { do this },
            "something else" --> { do something else },
            "a third thing" --> { do a third thing },
            any --> default value
        ]
    }
}

{ # 'for'/'for each' statement/expression
    for each item in | do | : {
        transform each @1 through @2
        [] # discard the result
    }
    for each | do | : using for each item in do

    #{ Examples
    -------------------- }#

    example {
        for each item in [1, 1, 2, 3, 5, 8] do {
            
        }
    }
}

#{ Tests
-------------------------------------------------- }#

{ # Possible join() implementation
    join | separated by | : {
        items to join : mutable @1[string]

        # IMPORTANT: `restrict |` must not make a copy of the map (to alter its metadata), or this won't work
        first : extract [any] from restrict using back for reading items to join
        others : extract [any] from restrict using not back for reading items to join

        join strings | and | : { combine [@1[string], @2[string]] }
        combine [first, translate each others through using join strings @2[string] and]
    }

    #{ (string[] items_to_join)
        first = extract([any], restrict(for(back, reading), items_to_join))
        rest = extract([any], restrict(for(not(back), reading), items_to_join))
    }#
}
